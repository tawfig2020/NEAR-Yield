const { exec } = require('child_process');
const axios = require('axios');
const WebSocket = require('ws');
const fs = require('fs').promises;
const yaml = require('js-yaml');

class SecurityTester {
  constructor(config) {
    this.config = config;
    this.results = [];
  }

  async loadConfig() {
    const configFile = await fs.readFile('../config/security.yaml', 'utf8');
    return yaml.load(configFile).security.penetration_testing;
  }

  async testEndpoint(endpoint, method, payload) {
    try {
      // Test for SQL Injection
      const sqlPayloads = [
        "' OR '1'='1",
        "; DROP TABLE users--",
        "' UNION SELECT * FROM users--"
      ];

      for (const payload of sqlPayloads) {
        const response = await axios({
          method,
          url: `${endpoint}?q=${payload}`,
          validateStatus: () => true
        });

        if (response.data.includes('SQL')) {
          this.results.push({
            type: 'SQL_INJECTION',
            severity: 'CRITICAL',
            endpoint,
            payload
          });
        }
      }

      // Test for XSS
      const xssPayloads = [
        "<script>alert('xss')</script>",
        "javascript:alert('xss')",
        "<img src='x' onerror='alert(1)'>"
      ];

      for (const payload of xssPayloads) {
        const response = await axios({
          method,
          url: endpoint,
          data: { input: payload },
          validateStatus: () => true
        });

        if (response.data.includes(payload)) {
          this.results.push({
            type: 'XSS',
            severity: 'HIGH',
            endpoint,
            payload
          });
        }
      }

      // Test for Authentication Bypass
      const authTests = [
        { headers: {} },
        { headers: { Authorization: 'Bearer invalid' } },
        { headers: { Authorization: 'Bearer null' } }
      ];

      for (const test of authTests) {
        const response = await axios({
          method,
          url: endpoint,
          ...test,
          validateStatus: () => true
        });

        if (response.status !== 401) {
          this.results.push({
            type: 'AUTH_BYPASS',
            severity: 'CRITICAL',
            endpoint,
            status: response.status
          });
        }
      }

      // Test Rate Limiting
      const requests = Array(150).fill().map(() => 
        axios({
          method,
          url: endpoint,
          validateStatus: () => true
        })
      );

      const responses = await Promise.all(requests);
      const rateLimited = responses.filter(r => r.status === 429).length;

      if (rateLimited === 0) {
        this.results.push({
          type: 'RATE_LIMIT_MISSING',
          severity: 'HIGH',
          endpoint
        });
      }

    } catch (error) {
      console.error(`Error testing ${endpoint}:`, error.message);
    }
  }

  async testWebSocket(url) {
    try {
      // Test WebSocket connection security
      const ws = new WebSocket(url);

      // Test unauthorized connection
      await new Promise((resolve) => {
        ws.on('open', () => {
          this.results.push({
            type: 'WS_UNAUTH_CONNECTION',
            severity: 'HIGH',
            endpoint: url
          });
          ws.close();
          resolve();
        });

        ws.on('error', resolve);
      });

      // Test message injection
      const ws2 = new WebSocket(url);
      await new Promise((resolve) => {
        ws2.on('open', () => {
          const maliciousPayloads = [
            '"><script>alert(1)</script>',
            '{"type":"__proto__","payload":"malicious"}'
          ];

          maliciousPayloads.forEach(payload => {
            ws2.send(payload);
          });

          setTimeout(() => {
            ws2.close();
            resolve();
          }, 1000);
        });
      });

    } catch (error) {
      console.error('WebSocket test error:', error.message);
    }
  }

  async runNmap(target) {
    return new Promise((resolve, reject) => {
      exec(`nmap -sS -sV ${target}`, (error, stdout, stderr) => {
        if (error) {
          reject(error);
          return;
        }
        resolve(stdout);
      });
    });
  }

  async testContractSecurity(contractId) {
    try {
      // Test contract access control
      const accessTests = [
        'view_state()',
        'update_config({"owner": "attacker.near"})',
        'withdraw({"amount": "1000000000000000000000000"})'
      ];

      for (const test of accessTests) {
        const result = await exec(`near view ${contractId} ${test}`);
        if (!result.stderr.includes('unauthorized')) {
          this.results.push({
            type: 'CONTRACT_ACCESS_CONTROL',
            severity: 'CRITICAL',
            contractId,
            test
          });
        }
      }

    } catch (error) {
      console.error('Contract security test error:', error.message);
    }
  }

  generateReport() {
    const critical = this.results.filter(r => r.severity === 'CRITICAL');
    const high = this.results.filter(r => r.severity === 'HIGH');
    const medium = this.results.filter(r => r.severity === 'MEDIUM');

    return {
      summary: {
        total: this.results.length,
        critical: critical.length,
        high: high.length,
        medium: medium.length
      },
      findings: this.results,
      timestamp: new Date().toISOString()
    };
  }

  async saveReport(report) {
    const filename = `pentest-report-${new Date().toISOString()}.json`;
    await fs.writeFile(filename, JSON.stringify(report, null, 2));
    console.log(`Report saved to ${filename}`);
  }
}

async function main() {
  try {
    const tester = new SecurityTester();
    const config = await tester.loadConfig();

    // Test API endpoints
    for (const target of config.targets) {
      if (target.url.startsWith('http')) {
        await tester.testEndpoint(target.url, 'GET');
        await tester.testEndpoint(target.url, 'POST');
      } else if (target.url.startsWith('ws')) {
        await tester.testWebSocket(target.url);
      }
    }

    // Test contract security
    await tester.testContractSecurity(process.env.CONTRACT_ID);

    // Generate and save report
    const report = tester.generateReport();
    await tester.saveReport(report);

    // Exit with error if critical findings exist
    if (report.summary.critical > 0) {
      process.exit(1);
    }

  } catch (error) {
    console.error('Penetration testing failed:', error);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}
